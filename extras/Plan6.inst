// *** Instinct Robot Plan generated by dia/instinctgen.py ***
// *** 2016-12-19 22:26:24 C:\Users\rwortham\Documents\Bath\University\Arduino Robot\Instinct-Dia\Plan6.inst

// *** First, clear the old plan and initialise the buffers ***
PLAN R C
// AP=10, APE=53, C=4, CE=12, D=6, A=32
PLAN R I 10 53 4 12 6 32

// *** These are the Plan Elements. ***

// CompetenceElement: AheadPossibleObstacle
// 	Parents: ForwardAvoidingObstacle
// 	Children: TurnIfNecessary
//	Priority=3
//	RetryLimit=0
//	Sense=MinRangeAhead
//	Comparator=GT	// EQ, NE, GT, LT, TR, FL
//	SenseValue=400
//	SenseHysteresis=10
//	SenseFlexLatchHysteresis=0
PLAN A E 42 2 104 3 0 20 2 400 10 0

// ActionPatternElement: SFH5b
// 	Parents: ScanForHuman
// 	Children: StopVerticalScan
//	Order=5
PLAN A L 102 76 29 5

// CompetenceElement: NoScanning
// 	Parents: ForwardAvoidingObstacle
// 	Children: FastHorizontalScan
//	Priority=2
//	RetryLimit=0
//	Sense=HScanReady
//	Comparator=EQ	// EQ, NE, GT, LT, TR, FL
//	SenseValue=0
//	SenseHysteresis=0
//	SenseFlexLatchHysteresis=0
PLAN A E 44 2 40 2 0 21 0 0 0 0

// Action: AheadMedium
// 	Parents: OA1
//	Action=SetSpeed
//	ActionValue=55
PLAN A A 14 1 55

// Start full scan. One cell is done every ActionValue
// Action: ScanHuman
// 	Parents: SFH3
//	Action=Scan
//	ActionValue=500
PLAN A A 81 19 500

// CompetenceElement: HumanPresent
// 	Parents: CheckForHuman
// 	Children: FoundAHuman
//	Priority=1
//	RetryLimit=0
//	Sense=ConfHuman
//	Comparator=EQ	// EQ, NE, GT, LT, TR, FL
//	SenseValue=2
//	SenseHysteresis=0
//	SenseFlexLatchHysteresis=0
PLAN A E 88 87 90 1 0 25 0 2 0 0

// Look for a human detection signal from the PIR, with a timeout of 8 seconds.
// Action: WaitForHumanDetector
// 	Parents: SFH7
//	Action=ConfirmHuman
//	ActionValue=9000
PLAN A A 85 20 9000

// Action: MoveAway
// 	Parents: FAH5
//	Action=MoveBy
//	ActionValue=-100
PLAN A A 109 2 -100

// ActionPattern: ObjectsAround
// 	Parents: FS3
// 	Children: OA2, OA1
PLAN A P 54

// Action: TurnRight10
// 	Parents: FAH2, FAH4
//	Action=Turn
//	ActionValue=10
PLAN A A 98 3 10

// ActionPatternElement: TA4
// 	Parents: TurnAvoid
// 	Children: FastHorizontalScan
//	Order=4
PLAN A L 58 45 40 4

// ActionPatternElement: TA5
// 	Parents: TurnAvoid
// 	Children: WaitForScanning
//	Order=5
PLAN A L 47 45 41 5

// ActionPatternElement: TA1
// 	Parents: TurnAvoid
// 	Children: Stop
//	Order=1
PLAN A L 103 45 13 1

// ActionPatternElement: TA2
// 	Parents: TurnAvoid
// 	Children: StopHorizontalScan
//	Order=2
PLAN A L 57 45 27 2

// ActionPatternElement: TA3
// 	Parents: TurnAvoid
// 	Children: TurnToAvoid
//	Order=3
PLAN A L 46 45 43 3

// ActionPatternElement: SFH6b
// 	Parents: ScanForHuman
// 	Children: LookForwardForHuman
//	Order=6
PLAN A L 107 76 108 6

// ActionPatternElement: SFH6a
// 	Parents: ScanForHuman
// 	Children: LookUpForHuman
//	Order=6
PLAN A L 83 76 80 6

// Simple Drive that stops the robot by sleeping for a long time if the motors are stalled e.g. by collision. This Drive has the highest possible priority, so cannot be overridden.
// Drive: ProtectMotors
// 	Children: SignalCrashAndSleep
//	Priority=255
//	Sense=MotorCurrent
//	Comparator=GT	// EQ, NE, GT, LT, TR, FL
//	SenseValue=2500
//	SenseHysteresis=2501
//	SenseFlexLatchHysteresis=0
PLAN A D 21 23 255 0 17 2 2500 2501 0 0 0 0

// Action: AheadSlow
// 	Parents: ON1
//	Action=SetSpeed
//	ActionValue=35
PLAN A A 12 1 35

// ActionPatternElement: SCAS6
// 	Parents: SignalCrashAndSleep
// 	Children: Sleep15Seconds
//	Order=5
PLAN A L 26 23 22 5

// ActionPatternElement: SCAS5
// 	Parents: SignalCrashAndSleep
// 	Children: FlashWarning
//	Order=4
PLAN A L 112 23 113 4

// ActionPatternElement: SCAS4
// 	Parents: SignalCrashAndSleep
// 	Children: LookUp
//	Order=3
PLAN A L 30 23 31 3

// ActionPatternElement: SCAS3
// 	Parents: SignalCrashAndSleep
// 	Children: StopVerticalScan
//	Order=2
PLAN A L 28 23 29 2

// ActionPatternElement: SCAS2
// 	Parents: SignalCrashAndSleep
// 	Children: StopHorizontalScan
//	Order=2
PLAN A L 25 23 27 2

// ActionPatternElement: SCAS1
// 	Parents: SignalCrashAndSleep
// 	Children: Stop
//	Order=1
PLAN A L 24 23 13 1

// CompetenceElement: NoHumanPresent
// 	Parents: CheckForHuman
// 	Children: NoHuman
//	Priority=1
//	RetryLimit=0
//	Sense=ConfHuman
//	Comparator=NE	// EQ, NE, GT, LT, TR, FL
//	SenseValue=2
//	SenseHysteresis=0
//	SenseFlexLatchHysteresis=0
PLAN A E 89 87 114 1 0 25 1 2 0 0

// Raise head to point upwards
// Action: LookUp
// 	Parents: SCAS4
//	Action=VMoveHead
//	ActionValue=90
PLAN A A 31 8 90

// ActionPatternElement: OA2
// 	Parents: ObjectsAround
// 	Children: FastHorizontalScan
//	Order=2
PLAN A L 56 54 40 2

// ActionPatternElement: OA1
// 	Parents: ObjectsAround
// 	Children: AheadMedium
//	Order=1
PLAN A L 55 54 14 1

// Activated when I think I've spotted a human. Sense hysteresis means it persists with this drive until completed, unless overridden by a higher priority drive
// Drive: DetectHuman
// 	Children: ScanForHuman
//	Priority=230
//	Sense=HumanAhead
//	Comparator=GT	// EQ, NE, GT, LT, TR, FL
//	SenseValue=0
//	SenseHysteresis=1
//	SenseFlexLatchHysteresis=0
PLAN A D 75 76 230 0 23 2 0 1 0 0 0 0

// Drive forward, adjusting speed to free space ahead
// Competence: ForwardSafely
// 	Parents: AheadFree, TIN1
// 	Children: FS4, FS3, FS2, FS1
//	UseORWithinCEGroup=0
PLAN A C 16 0

// look ahead to point to human
// Action: LookForwardForHuman
// 	Parents: SFH6b
//	Action=HMoveHead
//	ActionValue=75
PLAN A A 108 7 75

// Stop Vertical head scanning
// Action: StopVerticalScan
// 	Parents: SCAS3, SFH5b, SAS3
//	Action=VScan
//	ActionValue=0
PLAN A A 29 11 0

// Check if we really need to turn to face a more open angle, and if we do then do it.
// Competence: TurnIfNecessary
// 	Parents: AheadPossibleObstacle
// 	Children: TIN1, TIN2
//	UseORWithinCEGroup=1
PLAN A C 104 1

// ActionPatternElement: SFH5a
// 	Parents: ScanForHuman
// 	Children: StopHorizontalScan
//	Order=5
PLAN A L 99 76 27 5

// Action: TurnRight180
// 	Parents: FAH6
//	Action=Turn
//	ActionValue=180
PLAN A A 111 3 180

// ActionPatternElement: SFH8
// 	Parents: ScanForHuman
// 	Children: CheckForHuman
//	Order=8
PLAN A L 86 76 87 8

// CompetenceElement: FS1
// 	Parents: ForwardSafely
// 	Children: Stop
//	Priority=1
//	Sense=MinRangeAhead
//	Comparator=LT	// EQ, NE, GT, LT, TR, FL
//	SenseValue=400
//	SenseHysteresis=10
//	SenseFlexLatchHysteresis=0
PLAN A E 17 16 13 1 0 20 3 400 10 0

// ActionPatternElement: SFH3
// 	Parents: ScanForHuman
// 	Children: ScanHuman
//	Order=3
PLAN A L 78 76 81 3

// CompetenceElement: AheadBlocked
// 	Parents: ForwardAvoidingObstacle
// 	Children: ReverseTurnAvoid
//	Priority=2
//	RetryLimit=0
//	Sense=MinRangeAhead
//	Comparator=GT	// EQ, NE, GT, LT, TR, FL
//	SenseValue=0
//	SenseHysteresis=10
//	SenseFlexLatchHysteresis=0
PLAN A E 4 2 5 2 0 20 2 0 10 0

// Waits until we have a complete scan of the territory ahead
// Action: WaitForScanning
// 	Parents: RTA6, TA5, SAS12
//	Action=WaitHScan
//	ActionValue=0
PLAN A A 41 15 0

// ActionPatternElement: SFH7
// 	Parents: ScanForHuman
// 	Children: WaitForHumanDetector
//	Order=7
PLAN A L 84 76 85 7

// CompetenceElement: FS2
// 	Parents: ForwardSafely
// 	Children: ObjectsNear
//	Priority=2
//	Sense=MinRangeAhead
//	Comparator=GT	// EQ, NE, GT, LT, TR, FL
//	SenseValue=400
//	SenseHysteresis=10
//	SenseFlexLatchHysteresis=0
PLAN A E 18 16 72 2 0 20 2 400 10 0

// ActionPatternElement: SFH4
// 	Parents: ScanForHuman
// 	Children: WaitForScan
//	Order=4
PLAN A L 79 76 82 4

// ActionPattern: ObjectsNear
// 	Parents: FS2
// 	Children: ON2, ON1
PLAN A P 72

// Roam around once I can see where I'm going
// Drive: Explore
// 	Children: ForwardAvoidingObstacle
//	Priority=100
//	Sense=Sleeping
//	Comparator=EQ	// EQ, NE, GT, LT, TR, FL
//	SenseValue=0
//	SenseHysteresis=0
//	SenseFlexLatchHysteresis=0
PLAN A D 1 2 100 0 8 0 0 0 0 0 0 0

// Action: FlashSuccess
// 	Parents: FAH1
//	Action=FlashColour
//	ActionValue=6002	// 2 = Green
PLAN A A 101 21 6002

// Check if we have a human in view
// Competence: CheckForHuman
// 	Parents: SFH8
// 	Children: NoHumanPresent, HumanPresent
//	UseORWithinCEGroup=1
PLAN A C 87 1

// Action: Wait1Second
// 	Parents: SAS5, SAS10, SAS7
//	Action=Wait
//	ActionValue=1000
PLAN A A 66 12 1000

// Action: AheadFull
// 	Parents: AC2
//	Action=SetSpeed
//	ActionValue=100
PLAN A A 15 1 100

// Lower head to point ahead
// Action: UnfurlHead
// 	Parents: SAS9
//	Action=VMoveHead
//	ActionValue=180
PLAN A A 69 8 180

// Raise head to point to body
// Action: TuckHead
// 	Parents: SAS6
//	Action=VMoveHead
//	ActionValue=60
PLAN A A 63 8 60

// Waits until we have a complete scan
// Action: WaitForScan
// 	Parents: SFH4
//	Action=WaitScan
//	ActionValue=0
PLAN A A 82 18 0

// Stop Horizontal head scanning
// Action: StopHorizontalScan
// 	Parents: SCAS2, RTA3, SFH5a, TA2, SAS2
//	Action=HScan
//	ActionValue=0
PLAN A A 27 10 0

// Action: Turn45Degrees
// 	Parents: RTA4
//	Action=TurnMostOpenDir
//	ActionValue=45
PLAN A A 11 14 45

// ActionPattern: ScanForHuman
// 	Parents: DetectHuman
// 	Children: SFH6b, SFH5b, SFH5a, SFH8, SFH7, SFH6a, SFH4, SFH3, SFH1
PLAN A P 76

// Raise head to point to human
// Action: LookUpForHuman
// 	Parents: SFH6a
//	Action=VMoveHead
//	ActionValue=135
PLAN A A 80 8 135

// If I get too close to an IR reflector, then take avoiding action
// Drive: EmergencyAvoidObstacle
// 	Children: ReverseTurnAvoid
//	Priority=150
//	Sense=EmergAvoidDist
//	Comparator=LT	// EQ, NE, GT, LT, TR, FL
//	SenseValue=220
//	SenseHysteresis=25
//	SenseFlexLatchHysteresis=0
PLAN A D 71 5 150 0 27 3 220 25 0 0 0 0

// Point head forwards
// Action: HeadStraight
// 	Parents: SAS4
//	Action=HMoveHead
//	ActionValue=75
PLAN A A 64 7 75

// Action: TurnToAvoid
// 	Parents: TA3
//	Action=TurnToMostOpen
//	ActionValue=1
PLAN A A 43 13 1

// ActionPattern: FoundAHuman
// 	Parents: HumanPresent
// 	Children: FAH7, FAH5, FAH4, FAH6, FAH3, FAH2, FAH1
PLAN A P 90

// (NULL)
// Action: FlashFail
// 	Parents: NH1
//	Action=FlashColour
//	ActionValue=3004	// 4 = Red
PLAN A A 117 21 3004

// ActionPatternElement: SAS5
// 	Parents: StopAndSleep
// 	Children: Wait1Second
//	Order=4
PLAN A L 65 33 66 4

// ActionPatternElement: SAS4
// 	Parents: StopAndSleep
// 	Children: HeadStraight
//	Order=3
PLAN A L 62 33 64 3

// ActionPatternElement: SAS7
// 	Parents: StopAndSleep
// 	Children: Wait1Second
//	Order=6
PLAN A L 67 33 66 6

// ActionPatternElement: SAS6
// 	Parents: StopAndSleep
// 	Children: TuckHead
//	Order=5
PLAN A L 61 33 63 5

// ActionPatternElement: SAS1
// 	Parents: StopAndSleep
// 	Children: Stop
//	Order=1
PLAN A L 34 33 13 1

// ActionPatternElement: SAS3
// 	Parents: StopAndSleep
// 	Children: StopVerticalScan
//	Order=2
PLAN A L 37 33 29 2

// ActionPatternElement: SAS2
// 	Parents: StopAndSleep
// 	Children: StopHorizontalScan
//	Order=2
PLAN A L 35 33 27 2

// ActionPattern: SignalCrashAndSleep
// 	Parents: ProtectMotors
// 	Children: SCAS5, SCAS4, SCAS6, SCAS3, SCAS2, SCAS1
PLAN A P 23

// ActionPatternElement: SAS9
// 	Parents: StopAndSleep
// 	Children: UnfurlHead
//	Order=8
PLAN A L 68 33 69 8

// ActionPatternElement: SAS8
// 	Parents: StopAndSleep
// 	Children: Sleep10Seconds
//	Order=7
PLAN A L 36 33 38 7

// ActionPattern: StopAndSleep
// 	Parents: Sleep
// 	Children: SAS10, SAS9, SAS7, SAS5, SAS4, SAS6, SAS12, SAS11, SAS8, SAS3, SAS2, SAS1
PLAN A P 33

// ActionPattern: AllClear
// 	Parents: FS4
// 	Children: AC2, AC1
PLAN A P 49

// ActionPatternElement: FAH7
// 	Parents: FoundAHuman
// 	Children: ResetHumanDetector
//	Order=7
PLAN A L 110 90 91 7

// ActionPatternElement: FAH6
// 	Parents: FoundAHuman
// 	Children: TurnRight180
//	Order=6
PLAN A L 95 90 111 6

// ActionPatternElement: FAH5
// 	Parents: FoundAHuman
// 	Children: MoveAway
//	Order=5
PLAN A L 97 90 109 5

// ActionPatternElement: FAH4
// 	Parents: FoundAHuman
// 	Children: TurnRight10
//	Order=4
PLAN A L 96 90 98 4

// ActionPatternElement: FAH3
// 	Parents: FoundAHuman
// 	Children: TurnLeft20
//	Order=3
PLAN A L 94 90 100 3

// ActionPatternElement: FAH2
// 	Parents: FoundAHuman
// 	Children: TurnRight10
//	Order=2
PLAN A L 93 90 98 2

// ActionPatternElement: FAH1
// 	Parents: FoundAHuman
// 	Children: FlashSuccess
//	Order=1
PLAN A L 92 90 101 1

// Simple Drive that ensures if we are moving forwards then we are scanning around. It seems like a basic instinct is to look when we are moving.
// Drive: MovingSoLook
// 	Children: FastHorizontalScan
//	Priority=245
//	Sense=MovingHScanInterval
//	Comparator=GT	// EQ, NE, GT, LT, TR, FL
//	SenseValue=10000
//	SenseHysteresis=0
//	SenseFlexLatchHysteresis=0
PLAN A D 39 40 245 0 18 2 10000 0 0 0 0 0

// ActionPatternElement: AC2
// 	Parents: AllClear
// 	Children: AheadFull
//	Order=2
PLAN A L 51 49 15 2

// ActionPatternElement: AC1
// 	Parents: AllClear
// 	Children: SlowHScan
//	Order=1
PLAN A L 50 49 52 1

// CompetenceElement: FS3
// 	Parents: ForwardSafely
// 	Children: ObjectsAround
//	Priority=3
//	Sense=MinRangeAhead
//	Comparator=GT	// EQ, NE, GT, LT, TR, FL
//	SenseValue=1250
//	SenseHysteresis=10
//	SenseFlexLatchHysteresis=0
PLAN A E 19 16 54 3 0 20 2 1250 10 0

// CompetenceElement: FS4
// 	Parents: ForwardSafely
// 	Children: AllClear
//	Priority=4
//	Sense=MinRangeAhead
//	Comparator=GT	// EQ, NE, GT, LT, TR, FL
//	SenseValue=2500
//	SenseHysteresis=15
//	SenseFlexLatchHysteresis=0
PLAN A E 20 16 49 4 0 20 2 2500 15 0

// ActionPattern: NoHuman
// 	Parents: NoHumanPresent
// 	Children: NH2, NH1
PLAN A P 114

// ActionPatternElement: RTA1
// 	Parents: ReverseTurnAvoid
// 	Children: Stop
//	Order=1
PLAN A L 6 5 13 1

// ActionPatternElement: RTA3
// 	Parents: ReverseTurnAvoid
// 	Children: StopHorizontalScan
//	Order=3
PLAN A L 53 5 27 3

// ActionPatternElement: RTA2
// 	Parents: ReverseTurnAvoid
// 	Children: MoveBack
//	Order=2
PLAN A L 7 5 10 2

// ActionPatternElement: RTA5
// 	Parents: ReverseTurnAvoid
// 	Children: FastHorizontalScan
//	Order=5
PLAN A L 48 5 40 5

// ActionPatternElement: RTA4
// 	Parents: ReverseTurnAvoid
// 	Children: Turn45Degrees
//	Order=4
PLAN A L 8 5 11 4

// ActionPatternElement: RTA6
// 	Parents: ReverseTurnAvoid
// 	Children: WaitForScanning
//	Order=6
PLAN A L 9 5 41 6

// CompetenceElement: TIN2
// 	Parents: TurnIfNecessary
// 	Children: TurnAvoid
//	Priority=1
//	RetryLimit=0
//	Sense=MinRangeAhead
//	Comparator=LT	// EQ, NE, GT, LT, TR, FL
//	SenseValue=600
//	SenseHysteresis=10
//	SenseFlexLatchHysteresis=0
PLAN A E 106 104 45 1 0 20 3 600 10 0

// CompetenceElement: TIN1
// 	Parents: TurnIfNecessary
// 	Children: ForwardSafely
//	Priority=1
//	RetryLimit=0
//	Sense=MinRangeAhead
//	Comparator=GT	// EQ, NE, GT, LT, TR, FL
//	SenseValue=600
//	SenseHysteresis=10
//	SenseFlexLatchHysteresis=0
PLAN A E 105 104 16 1 0 20 2 600 10 0

// Action: Stop
// 	Parents: RTA1, FS1, SFH1, SCAS1, TA1, SAS1
//	Action=Stop
//	ActionValue=0
PLAN A A 13 4 0

// Action: FlashWarning
// 	Parents: SCAS5
//	Action=FlashColour
//	ActionValue=8004	// 4 = Red
PLAN A A 113 21 8004

// ActionPattern: TurnAvoid
// 	Parents: TIN2
// 	Children: TA1, TA4, TA2, TA5, TA3
PLAN A P 45

// Action: MoveBack
// 	Parents: RTA2
//	Action=MoveBy
//	ActionValue=-100
PLAN A A 10 2 -100

// Simple Drive that stops the robot periodically when it is near objects. This extends battery life and avoids the robot stopping in open areas when it may be damaged.
// Drive: Sleep
// 	Children: StopAndSleep
//	Priority=5
//	Sense=EmergAvoidDist
//	Comparator=LT	// EQ, NE, GT, LT, TR, FL
//	SenseValue=300
//	SenseHysteresis=5000
//	SenseFlexLatchHysteresis=5000
//	RampIncrement=2
//	UrgencyMultiplier=0
//	RampInterval=1
PLAN A D 32 33 5 0 27 3 300 5000 5000 2 0 1

// CompetenceElement: AheadFree
// 	Parents: ForwardAvoidingObstacle
// 	Children: ForwardSafely
//	Priority=4
//	RetryLimit=0
//	Sense=MinRangeAhead
//	Comparator=GT	// EQ, NE, GT, LT, TR, FL
//	SenseValue=1000
//	SenseHysteresis=10
//	SenseFlexLatchHysteresis=0
PLAN A E 3 2 16 4 0 20 2 1000 10 0

// Reset The Human Detector
// Action: ResetHumanDetector
// 	Parents: FAH7, NH2
//	Action=ResetHD
//	ActionValue=0
PLAN A A 91 17 0

// Sleep for 10 Seconds
// Action: Sleep10Seconds
// 	Parents: SAS8
//	Action=Sleep
//	ActionValue=10
PLAN A A 38 5 10

// ActionPatternElement: NH1
// 	Parents: NoHuman
// 	Children: FlashFail
//	Order=1
PLAN A L 115 114 117 1

// ActionPatternElement: NH2
// 	Parents: NoHuman
// 	Children: ResetHumanDetector
//	Order=2
PLAN A L 116 114 91 2

// ActionPatternElement: ON2
// 	Parents: ObjectsNear
// 	Children: FastHorizontalScan
//	Order=2
PLAN A L 74 72 40 2

// ActionPatternElement: ON1
// 	Parents: ObjectsNear
// 	Children: AheadSlow
//	Order=1
PLAN A L 73 72 12 1

// Drive forward, avoiding objects as they are sensed
// Competence: ForwardAvoidingObstacle
// 	Parents: Explore
// 	Children: NoScanning, AheadPossibleObstacle, AheadBlocked, AheadFree
//	UseORWithinCEGroup=1
PLAN A C 2 1

// ActionPattern: ReverseTurnAvoid
// 	Parents: AheadBlocked, EmergencyAvoidObstacle
// 	Children: RTA5, RTA3, RTA6, RTA4, RTA2, RTA1
PLAN A P 5

// Start slow Horizontal head scanning
// Action: SlowHScan
// 	Parents: AC1
//	Action=HScan
//	ActionValue=3000
PLAN A A 52 10 3000

// Action: TurnLeft20
// 	Parents: FAH3
//	Action=Turn
//	ActionValue=-20
PLAN A A 100 3 -20

// ActionPatternElement: SAS11
// 	Parents: StopAndSleep
// 	Children: FastHorizontalScan
//	Order=10
PLAN A L 59 33 40 10

// ActionPatternElement: SAS10
// 	Parents: StopAndSleep
// 	Children: Wait1Second
//	Order=9
PLAN A L 70 33 66 9

// ActionPatternElement: SAS12
// 	Parents: StopAndSleep
// 	Children: WaitForScanning
//	Order=11
PLAN A L 60 33 41 11

// Sleep for 15 Seconds
// Action: Sleep15Seconds
// 	Parents: SCAS6
//	Action=Sleep
//	ActionValue=15
PLAN A A 22 5 15

// ActionPatternElement: SFH1
// 	Parents: ScanForHuman
// 	Children: Stop
//	Order=1
PLAN A L 77 76 13 1

// Start fast Horizontal head scanning
// Action: FastHorizontalScan
// 	Parents: MovingSoLook, RTA5, NoScanning, ON2, OA2, TA4, SAS11
//	Action=HScan
//	ActionValue=2000
PLAN A A 40 10 2000

// *** Plan Element Names follow ... ***

// CompetenceElement: AheadPossibleObstacle
PELEM AheadPossibleObstacle=42

// ActionPatternElement: SFH5b
PELEM SFH5b=102

// CompetenceElement: NoScanning
PELEM NoScanning=44

// Action: AheadMedium
PELEM AheadMedium=14

// Start full scan. One cell is done every ActionValue
// Action: ScanHuman
PELEM ScanHuman=81

// CompetenceElement: HumanPresent
PELEM HumanPresent=88

// Look for a human detection signal from the PIR, with a timeout of 8 seconds.
// Action: WaitForHumanDetector
PELEM WaitForHumanDetector=85

// Action: MoveAway
PELEM MoveAway=109

// ActionPattern: ObjectsAround
PELEM ObjectsAround=54

// Action: TurnRight10
PELEM TurnRight10=98

// ActionPatternElement: TA4
PELEM TA4=58

// ActionPatternElement: TA5
PELEM TA5=47

// ActionPatternElement: TA1
PELEM TA1=103

// ActionPatternElement: TA2
PELEM TA2=57

// ActionPatternElement: TA3
PELEM TA3=46

// ActionPatternElement: SFH6b
PELEM SFH6b=107

// ActionPatternElement: SFH6a
PELEM SFH6a=83

// Simple Drive that stops the robot by sleeping for a long time if the motors are stalled e.g. by collision. This Drive has the highest possible priority, so cannot be overridden.
// Drive: ProtectMotors
PELEM ProtectMotors=21

// Action: AheadSlow
PELEM AheadSlow=12

// ActionPatternElement: SCAS6
PELEM SCAS6=26

// ActionPatternElement: SCAS5
PELEM SCAS5=112

// ActionPatternElement: SCAS4
PELEM SCAS4=30

// ActionPatternElement: SCAS3
PELEM SCAS3=28

// ActionPatternElement: SCAS2
PELEM SCAS2=25

// ActionPatternElement: SCAS1
PELEM SCAS1=24

// CompetenceElement: NoHumanPresent
PELEM NoHumanPresent=89

// Raise head to point upwards
// Action: LookUp
PELEM LookUp=31

// ActionPatternElement: OA2
PELEM OA2=56

// ActionPatternElement: OA1
PELEM OA1=55

// Activated when I think I've spotted a human. Sense hysteresis means it persists with this drive until completed, unless overridden by a higher priority drive
// Drive: DetectHuman
PELEM DetectHuman=75

// Drive forward, adjusting speed to free space ahead
// Competence: ForwardSafely
PELEM ForwardSafely=16

// look ahead to point to human
// Action: LookForwardForHuman
PELEM LookForwardForHuman=108

// Stop Vertical head scanning
// Action: StopVerticalScan
PELEM StopVerticalScan=29

// Check if we really need to turn to face a more open angle, and if we do then do it.
// Competence: TurnIfNecessary
PELEM TurnIfNecessary=104

// ActionPatternElement: SFH5a
PELEM SFH5a=99

// Action: TurnRight180
PELEM TurnRight180=111

// ActionPatternElement: SFH8
PELEM SFH8=86

// CompetenceElement: FS1
PELEM FS1=17

// ActionPatternElement: SFH3
PELEM SFH3=78

// CompetenceElement: AheadBlocked
PELEM AheadBlocked=4

// Waits until we have a complete scan of the territory ahead
// Action: WaitForScanning
PELEM WaitForScanning=41

// ActionPatternElement: SFH7
PELEM SFH7=84

// CompetenceElement: FS2
PELEM FS2=18

// ActionPatternElement: SFH4
PELEM SFH4=79

// ActionPattern: ObjectsNear
PELEM ObjectsNear=72

// Roam around once I can see where I'm going
// Drive: Explore
PELEM Explore=1

// Action: FlashSuccess
PELEM FlashSuccess=101

// Check if we have a human in view
// Competence: CheckForHuman
PELEM CheckForHuman=87

// Action: Wait1Second
PELEM Wait1Second=66

// Action: AheadFull
PELEM AheadFull=15

// Lower head to point ahead
// Action: UnfurlHead
PELEM UnfurlHead=69

// Raise head to point to body
// Action: TuckHead
PELEM TuckHead=63

// Waits until we have a complete scan
// Action: WaitForScan
PELEM WaitForScan=82

// Stop Horizontal head scanning
// Action: StopHorizontalScan
PELEM StopHorizontalScan=27

// Action: Turn45Degrees
PELEM Turn45Degrees=11

// ActionPattern: ScanForHuman
PELEM ScanForHuman=76

// Raise head to point to human
// Action: LookUpForHuman
PELEM LookUpForHuman=80

// If I get too close to an IR reflector, then take avoiding action
// Drive: EmergencyAvoidObstacle
PELEM EmergencyAvoidObstacle=71

// Point head forwards
// Action: HeadStraight
PELEM HeadStraight=64

// Action: TurnToAvoid
PELEM TurnToAvoid=43

// ActionPattern: FoundAHuman
PELEM FoundAHuman=90

// (NULL)
// Action: FlashFail
PELEM FlashFail=117

// ActionPatternElement: SAS5
PELEM SAS5=65

// ActionPatternElement: SAS4
PELEM SAS4=62

// ActionPatternElement: SAS7
PELEM SAS7=67

// ActionPatternElement: SAS6
PELEM SAS6=61

// ActionPatternElement: SAS1
PELEM SAS1=34

// ActionPatternElement: SAS3
PELEM SAS3=37

// ActionPatternElement: SAS2
PELEM SAS2=35

// ActionPattern: SignalCrashAndSleep
PELEM SignalCrashAndSleep=23

// ActionPatternElement: SAS9
PELEM SAS9=68

// ActionPatternElement: SAS8
PELEM SAS8=36

// ActionPattern: StopAndSleep
PELEM StopAndSleep=33

// ActionPattern: AllClear
PELEM AllClear=49

// ActionPatternElement: FAH7
PELEM FAH7=110

// ActionPatternElement: FAH6
PELEM FAH6=95

// ActionPatternElement: FAH5
PELEM FAH5=97

// ActionPatternElement: FAH4
PELEM FAH4=96

// ActionPatternElement: FAH3
PELEM FAH3=94

// ActionPatternElement: FAH2
PELEM FAH2=93

// ActionPatternElement: FAH1
PELEM FAH1=92

// Simple Drive that ensures if we are moving forwards then we are scanning around. It seems like a basic instinct is to look when we are moving.
// Drive: MovingSoLook
PELEM MovingSoLook=39

// ActionPatternElement: AC2
PELEM AC2=51

// ActionPatternElement: AC1
PELEM AC1=50

// CompetenceElement: FS3
PELEM FS3=19

// CompetenceElement: FS4
PELEM FS4=20

// ActionPattern: NoHuman
PELEM NoHuman=114

// ActionPatternElement: RTA1
PELEM RTA1=6

// ActionPatternElement: RTA3
PELEM RTA3=53

// ActionPatternElement: RTA2
PELEM RTA2=7

// ActionPatternElement: RTA5
PELEM RTA5=48

// ActionPatternElement: RTA4
PELEM RTA4=8

// ActionPatternElement: RTA6
PELEM RTA6=9

// CompetenceElement: TIN2
PELEM TIN2=106

// CompetenceElement: TIN1
PELEM TIN1=105

// Action: Stop
PELEM Stop=13

// Action: FlashWarning
PELEM FlashWarning=113

// ActionPattern: TurnAvoid
PELEM TurnAvoid=45

// Action: MoveBack
PELEM MoveBack=10

// Simple Drive that stops the robot periodically when it is near objects. This extends battery life and avoids the robot stopping in open areas when it may be damaged.
// Drive: Sleep
PELEM Sleep=32

// CompetenceElement: AheadFree
PELEM AheadFree=3

// Reset The Human Detector
// Action: ResetHumanDetector
PELEM ResetHumanDetector=91

// Sleep for 10 Seconds
// Action: Sleep10Seconds
PELEM Sleep10Seconds=38

// ActionPatternElement: NH1
PELEM NH1=115

// ActionPatternElement: NH2
PELEM NH2=116

// ActionPatternElement: ON2
PELEM ON2=74

// ActionPatternElement: ON1
PELEM ON1=73

// Drive forward, avoiding objects as they are sensed
// Competence: ForwardAvoidingObstacle
PELEM ForwardAvoidingObstacle=2

// ActionPattern: ReverseTurnAvoid
PELEM ReverseTurnAvoid=5

// Start slow Horizontal head scanning
// Action: SlowHScan
PELEM SlowHScan=52

// Action: TurnLeft20
PELEM TurnLeft20=100

// ActionPatternElement: SAS11
PELEM SAS11=59

// ActionPatternElement: SAS10
PELEM SAS10=70

// ActionPatternElement: SAS12
PELEM SAS12=60

// Sleep for 15 Seconds
// Action: Sleep15Seconds
PELEM Sleep15Seconds=22

// ActionPatternElement: SFH1
PELEM SFH1=77

// Start fast Horizontal head scanning
// Action: FastHorizontalScan
PELEM FastHorizontalScan=40

// *** Plan output complete. RobotSenses and RobotActions follow ... ***

// Front virtual sensor calculated from (FrontRight + RearRight)/2  - max 420mm
// RobotSense: IR_Right
//	SenseID=14
RSENSE IR_Right=14

// Rear left IR sensor - max 600mm
// RobotSense: IR_RearLeft
//	SenseID=3
RSENSE IR_RearLeft=3

// True when at least one full vertical head scan has been completed.
// RobotSense: VScanReady
//	SenseID=22
RSENSE VScanReady=22

// Ultrasonic range finder mounted on head. 0mm to 5000mm
// RobotSense: RangeFinder
//	SenseID=10
RSENSE RangeFinder=10

// Front right IR sensor - max 600mm
// RobotSense: IR_FrontRight
//	SenseID=1
RSENSE IR_FrontRight=1

// Returns ID of edge nearest to an obstacle (0-3), or 4 if no obstacle detected
// RobotSense: IR_NearestEdge
//	SenseID=16
RSENSE IR_NearestEdge=16

// Rear virtual sensor calculated from (RearRight + RearLeft)/2  - max 420mm
// RobotSense: IR_Rear
//	SenseID=6
RSENSE IR_Rear=6

// Returns 1 if there may be a human ahead of us. This depends on the PIR sensor, the distance to the object ahead, and the distance travelled since we detected the last human. There may be false positives, so we will need to investigate further to be sure.
// RobotSense: HumanAhead
//	SenseID=23
RSENSE HumanAhead=23

// Returns distance for emergency avoidance. Returns 600 when not moving and human sensed.
// RobotSense: EmergAvoidDist
//	SenseID=27
RSENSE EmergAvoidDist=27

// Front virtual sensor calculated from (FrontLeft + RearLeft)/2  - max 420mm
// RobotSense: IR_Left
//	SenseID=13
RSENSE IR_Left=13

// True when at least one entire head scan has been completed.
// RobotSense: ScanReady
//	SenseID=24
RSENSE ScanReady=24

// Minimum distance scanned by head. 0 to 5000mm. Only valid when ScanReady is true, otherwise returns zero.
// RobotSense: MinRangeAhead
//	SenseID=20
RSENSE MinRangeAhead=20

// Front virtual sensor calculated from (FrontRight + FrontLeft)/2  - max 420mm
// RobotSense: IR_Front
//	SenseID=5
RSENSE IR_Front=5

// Returns true if the robot tracks are moving
// RobotSense: Moving
//	SenseID=26
RSENSE Moving=26

// Front left IR sensor - max 600mm
// RobotSense: IR_FrontLeft
//	SenseID=2
RSENSE IR_FrontLeft=2

// Returns vertical scan interval if robot is stopped, zero otherwise.
// RobotSense: StoppedVScanInterval
//	SenseID=19
RSENSE StoppedVScanInterval=19

// Sum of drive motor currents in mA
// RobotSense: MotorCurrent
//	SenseID=17
RSENSE MotorCurrent=17

// 1 if robot is sleeping
// RobotSense: Sleeping
//	SenseID=8
RSENSE Sleeping=8

// True when at least one full horizontal head scan has been completed.
// RobotSense: HScanReady
//	SenseID=21
RSENSE HScanReady=21

// Returns ID of corner nearest to an obstacle (0-3), or 4 if no obstacle detected
// RobotSense: IR_NearestCorner
//	SenseID=15
RSENSE IR_NearestCorner=15

// Returns the result of the human detector. 0 = not detected, 1 = maybe, 2 = confirmed.
// RobotSense: ConfHuman
//	SenseID=25
RSENSE ConfHuman=25

// PIR sensor mounted on head. Can sense humans but also sometimes triggers when its moved.
// RobotSense: PIR
//	SenseID=12
RSENSE PIR=12

// Returns horizontal scan interval if robot is moving forwards, zero otherwise.
// RobotSense: MovingHScanInterval
//	SenseID=18
RSENSE MovingHScanInterval=18

// Just a random number 1-100
// RobotSense: Random
//	SenseID=7
RSENSE Random=7

// Rear right IR sensor - max 600mm
// RobotSense: IR_RearRight
//	SenseID=4
RSENSE IR_RearRight=4

// Minimum of IR_FrontLeft, IR_FrontRight and IR_Front
// RobotSense: FrontRange
//	SenseID=11
RSENSE FrontRange=11

// Always returns 50 - Good for testing
// RobotSense: Fifty
//	SenseID=9
RSENSE Fifty=9

// Waits until there is vertical scan data in column defined by ActionValue
// RobotAction: WaitVScan
//	ActionID=16
RACTION WaitVScan=16

// Flash any primary colour for Actionvalue mS. Lowest 3 bits of Actionvalue are RGB, remainder is delay in mS.
// RobotAction: FlashColour
//	ActionID=21
RACTION FlashColour=21

// Waits until there is data in all head matrix cells
// RobotAction: WaitScan
//	ActionID=18
RACTION WaitScan=18

// Reset the human detector
// RobotAction: ResetHD
//	ActionID=17
RACTION ResetHD=17

// Waits until a human definitely detected, with a timeout of nActionValue
// RobotAction: ConfirmHuman
//	ActionID=20
RACTION ConfirmHuman=20

// Stop and rotate a certain number of degrees clockwise
// RobotAction: Turn
//	ActionID=3
RACTION Turn=3

// Read the sensor matrix and turn to the most open path. The ActionValue is used to decide which vertical row of sensor cells to use.
// RobotAction: TurnToMostOpen
//	ActionID=13
RACTION TurnToMostOpen=13

// Waits until there is horizontal scan data in row defined by ActionValue
// RobotAction: WaitHScan
//	ActionID=15
RACTION WaitHScan=15

// Stop and set rudder to 0
// RobotAction: Stop
//	ActionID=4
RACTION Stop=4

// A test action that always fails
// RobotAction: Fail
//	ActionID=9
RACTION Fail=9

// Move robot head verically in degrees 0-180
// RobotAction: VMoveHead
//	ActionID=8
RACTION VMoveHead=8

// Start scanning robot head sensor vertically and horizontally, one cell every ActionValue milliseconds
// RobotAction: Scan
//	ActionID=19
RACTION Scan=19

// Set the speed 0-100%
// RobotAction: SetSpeed
//	ActionID=1
RACTION SetSpeed=1

// Move by a certain number of millimeters
// RobotAction: MoveBy
//	ActionID=2
RACTION MoveBy=2

// Abort sleep mode
// RobotAction: Wake
//	ActionID=6
RACTION Wake=6

// Read the IR sensors and turns to the most open path by ActionValue degrees. 
// RobotAction: TurnMostOpenDir
//	ActionID=14
RACTION TurnMostOpenDir=14

// Move robot head horizontally in degrees 0-180
// RobotAction: HMoveHead
//	ActionID=7
RACTION HMoveHead=7

// Sleep for ActionValue seconds
// RobotAction: Sleep
//	ActionID=5
RACTION Sleep=5

// Start scanning robot head sensor vertically, once every ActionValue milliseconds
// RobotAction: VScan
//	ActionID=11
RACTION VScan=11

// Start scanning robot head sensor horizontally, once every ActionValue milliseconds
// RobotAction: HScan
//	ActionID=10
RACTION HScan=10

// Just wait at this plan step for ActionValue mS. Useful after starting scanning before deciding what to do.
// RobotAction: Wait
//	ActionID=12
RACTION Wait=12

// *** Output completed. ***
